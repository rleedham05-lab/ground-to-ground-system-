import os
import math
import sys
import time
import matplotlib.pyplot as plt
import numpy as np

# --- SETUP FUNCTIONS 

# clear screen function
def clear_screen():
    clear = lambda: os.system('clear')
    clear()

# delay print function
def delay_print(s):
    """Prints a string character by character with a small delay."""
    for c in s:
        sys.stdout.write(c)
        sys.stdout.flush()
        time.sleep(0.010)
    sys.stdout.write('\n')

#  VALIDATION FUNCTION 

def value_checker(v_value, angle_value):
    """Checks if both input values can be successfully converted to floats."""
    try:
        # Attempt to convert both inputs to floats within the try block
        float(v_value)
        float(angle_value)
        
        # If we reach this point, both conversions succeeded.
        delay_print("✅ input accepted.")
        return True
        
    except ValueError:
        # If a ValueError was raised, the input was not a valid number.
        delay_print("❌ Invalid input detected. Please input valid numbers for both velocity and angle.")
        return False


# time peak of projectile 
def projectile_peak_time(v, angle_degrees, g):
    angle_radians = math.radians(angle_degrees) 
    T_peak = (v * math.sin(angle_radians)) / g
    return T_peak
    
# Finding projectile peak height 
def projectile_peak(v, angle_degrees, g):
    angle_radians = math.radians(angle_degrees)
    #calculating Y_max 
    Y_max = (v * math.sin(angle_radians))**2/(2*g)
    return Y_max

#finding time projectile spent in motion 
def calculate_time(v, angle_degrees, g):
    T_peak = projectile_peak_time(v, angle_degrees, g)
    Time = 2*T_peak
    return Time 

def range_calculator(total_time, v, angle):
    angle_radians = math.radians(angle)
    #calculating range using vertical displacement equation 
    Range = (v*math.cos(angle_radians))*total_time
    return Range 

# the current speed of object in y axis 
def new_speed_y(v, angle, current_time, g):
    angle_radians = math.radians(angle)
    current_speed_y = (math.sin(angle_radians)*v)-(current_time*g)
    return current_speed_y

# the current speed of the object in x axis   
def new_speed_x(v, angle):
    angle_radians = math.radians(angle)
    current_speed_x = math.cos(angle_radians)*v
    return current_speed_x

# the current displacement of a object in its y axis  
def new_displacment_y(current_speed_y, current_displacment_y, d_t):
    new_displacment = (current_speed_y*d_t) + current_displacment_y
    current_displacment = new_displacment
    return current_displacment 

# the current displacement of a object in its x axis 
def new_displacement_x(current_speed_x, current_displacment_x, d_t):
    new_displacment = (current_speed_x*d_t) + current_displacment_x
    current_displacment = new_displacment 
    return current_displacment 

# finding range for when y max is achieved 
def Range_at_y_max(peak_time, v, angle):
    angle_radians = math.radians(angle)
    current_speed_x = math.cos(angle_radians)*v
    Range_at_y_max = current_speed_x*peak_time  
    return Range_at_y_max

# --- MAIN EXECUTION ---

# initial interface for this function 
finished = False
while not finished:
    #setting constants and vectors 
    g = 9.81  # Acceleration due to gravity (constant)
    # Initialize main calculation variables
    v = 0
    Range = 0 
    # main variables for vector quantities 
    x_velocity = 0 
    y_velocity = 0
    x_displacment = 0
    y_displacment = 0
    angle = 0
    mass = 0
      
    correct = False 
    while not correct:
        # Start of outputs screen
        delay_print("PROJECTILE MOTION CALCULATOR")
        delay_print("============================")
        delay_print("You must enter Mass, Velocity, and Angle to continue.")
        delay_print("Type Y to continue")
        
        # User input loop for 'Y'
        correct_2 = False 
        while not correct_2:
            choice = input(">> ").upper()
            if choice == "Y":
                correct_2 = True  
                clear_screen()
            else:
                delay_print("Please type 'Y' to continue.")

        # Initial finding of mass 
        delay_print("What is the mass of the desired projectile (kg)?")
        correct_2 = False  
        while not correct_2:
            m_str = input("Mass (kg) >> ")
            try:
                #checks user input is numeric 
                m_float = float(m_str)
                if m_float <= 0:
                    delay_print("Mass must be greater than zero.")
                    continue
                mass = m_float 
                correct_2 = True  
                clear_screen()
            except ValueError:
                delay_print("❌ Please input a valid numeric value for mass.")
        
        # Finding value for velocity and the value of the angle 
        correct_2 = False  
        while not correct_2:
            delay_print("Please input the values you are aware of:")
            delay_print("1. What is the velocity of the object (m/s)?")
            delay_print("If this value is unknown, please type 'N/A'")
            
            v_input = input("Velocity (m/s) >> ").upper()

            # Subroutine for finding the value of v from kinetic energy
            if v_input == "N/A":
                clear_screen()
                delay_print("Please input the value of the kinetic energy (Joules):")
                
                # Nested loop for safe kinetic energy input
                k = 0
                k_correct = False
                while not k_correct:
                    k_str = input("Kinetic Energy (J) >> ")
                    try:
                        k = float(k_str)
                        if k < 0:
                            delay_print("Kinetic energy cannot be negative.")
                            continue
                        k_correct = True
                    except ValueError:
                        delay_print("❌ Invalid input for kinetic energy.")
                
                # Calculate v from K.E. (K = 0.5 * m * v^2)
                v = math.sqrt((2 * k) / mass) 
                delay_print(f"Calculated velocity (v): {v:.2f} m/s")
            else:
                # If user entered a value for v, use it as the string input for the checker
                v = v_input 

            delay_print("2. Please input the angle the projectile was launched at (degrees):")
            angle = input("Angle (degrees) >> ")  # Angle is stored as a string

            # Check if v (now either a number or a string) and angle (string) are valid numbers
            correct_2 = value_checker(v, angle)
            
            # If the checker passed, convert the final v and angle variables to floats
            if correct_2:
                # If v was 'N/A', it's already a float. If it was user input, it's a string, so we convert.
                v = float(v) 
                angle = float(angle)
                correct = True  # Break out of the outer 'correct' loop too

    # CALCULATE RESULTS
    
    #deceleration is calculated from mass times by the gravitational deceleration caused by gravity 
    total_time = calculate_time(v, angle, g)
    # find projectile time 
    peak_time = projectile_peak_time(v, angle, g)
    # find the projectile peak 
    max_height = projectile_peak(v, angle, g)
    # next step is to find the range
    Range = range_calculator(total_time, v, angle)
    print(f"Range: {Range}")
    print(f"Max Height: {max_height}")
    
    # the beginning of the use of graphs
    x_value = []
    y_value = []
    x_speed_value = []
    y_speed_value = []
    current_time = 0
    current_speed_y = 0
    current_speed_x = 0
    current_displacment_y = 0
    current_displacment_x = 0
    range_at_y_max = Range_at_y_max(peak_time, v, angle)
    
    #fonts are defined 
    font1 = {'family': 'sans-serif', 'color': 'black', 'size': 15}
    font2 = {'family': 'sans-serif', 'color': 'black', 'size': 10}  
    
    #plt.ion are checked to see if could run in the current software 
    try:
        plt.ion()
        print("Interactive mode is supported!\n")
        interactive = True 
    except (NotImplementedError, AttributeError):
        print("Interactive mode is NOT supported\n")
        interactive = False 
    
    delay_print("Would you like to continue Y/N?")
    continue_choice = input(">> ").upper()
    
    if continue_choice == "Y":
        done = False
        while not done:
            delay_print("Would you like to have data presented..\n")
            time.sleep(1.0)
            delay_print("1. Real time analysis\n")
            delay_print("2. 100 times speed\n")
            delay_print("3. 1000 times speed\n")
            delay_print("Please type 1/2/3")
            choice = input(">> ")
            if choice == "1":
                d_t = 0.001
                done = True
            elif choice == "2":
                d_t = 0.01
                done = True
            elif choice == "3":
                d_t = 1.0
                done = True
            else:
                delay_print("Please input a valid response")
        
        clear_screen()
        
        if interactive:
            #program of representation for a software that has the ability to be interactive 
            fig, ax = plt.subplots()
            line, = ax.plot([], [], "b-")
            ax.set_title("Displacement over time", fontdict=font1)
            ax.set_xlabel("Range (M)", fontdict=font2)
            ax.set_ylabel("Height (M)", fontdict=font2)
            ax.set_xlim(0, Range * 1.1)
            ax.set_ylim(0, max_height * 1.1)
            
            while current_displacment_y >= 0:
                #run subroutines to get vector quantities 
                current_speed_y = new_speed_y(v, angle, current_time, g)
                current_speed_x = new_speed_x(v, angle)
                current_displacment_y = new_displacment_y(current_speed_y, current_displacment_y, d_t)
                current_displacment_x = new_displacement_x(current_speed_x, current_displacment_x, d_t)
                x_value.append(current_displacment_x)
                y_value.append(current_displacment_y)
                x_speed_value.append(current_speed_x)
                y_speed_value.append(current_speed_y)
                
                print(f"Current speed in X axis (M/S): {current_speed_x:.2f}")
                print(f"Current speed in Y axis (M/S): {current_speed_y:.2f}")
                print(f"Current displacement in X axis (M): {current_displacment_x:.2f}")
                print(f"Current displacement in Y axis (M): {current_displacment_y:.2f}\n")
                
                current_time = current_time + d_t 
                
                line.set_data(x_value, y_value)
                plt.draw()
                plt.pause(0.001)
                time.sleep(0.001)
                clear_screen()
                clear = lambda: os.system('clear')
                clear()
        else:
            #subroutine for checking if the program running is not interactive 
            while current_displacment_y >= 0:
                # vector quantities are defined 
                current_speed_y = new_speed_y(v, angle, current_time, g)
                current_speed_x = new_speed_x(v, angle)
                current_displacment_y = new_displacment_y(current_speed_y, current_displacment_y, d_t)
                current_displacment_x = new_displacement_x(current_speed_x, current_displacment_x, d_t)
                x_value.append(current_displacment_x)
                y_value.append(current_displacment_y)
                x_speed_value.append(current_speed_x)
                y_speed_value.append(current_speed_y)
                print(f"Current speed in X axis (M/S): {current_speed_x:.2f}")
                print(f"Current speed in Y axis (M/S): {current_speed_y:.2f}")
                print(f"Current displacement in X axis (M): {current_displacment_x:.2f}")
                print(f"Current displacement in Y axis (M): {current_displacment_y:.2f}\n")
                
                time.sleep(0.001)
                current_time = current_time + d_t 
                clear = lambda: os.system('clear')
                clear()
            
            #manual plotting 
            plt.figure()
            plt.title("Displacement over time", fontdict=font1)
            plt.xlabel("Range (M)", fontdict=font2)
            plt.ylabel("Height (M)", fontdict=font2)
            plt.plot(x_value, y_value, label='Trajectory')
            # Plot the peak point (range at max height vs max height)
            plt.scatter(range_at_y_max, max_height, color='red', s=100, 
                       label=f'Peak:({range_at_y_max:.2f}m, {max_height:.2f}m)',
                       zorder=5)
            plt.legend()
            plt.grid(True)
            plt.show()
            plt.plot(x_value, y_value)
            plt.grid(True)
            range_at_y_max = np.range_at_y_max
            peak_time = np.peak_time
            plt.scatter(range_at_y_max,peak_time)
            plt.show()
            print(f"Total simulation time: {current_time:.2f}s")
            print(f"Calculated total time: {total_time:.2f}s")
            print(f"Peak time: {peak_time:.2f}s")
    else:
        clear_screen()
    
    # Ask if user wants to run again
    delay_print("\nWould you like to calculate another projectile? (Y/N)")
    restart = input(">> ").upper()
    if restart != "Y":
        finished = True
        delay_print("Thank you for using the Projectile Motion Calculator!")
